import os
import json
import base64
from datetime import datetime
import requests
import streamlit as st
import yaml
from textwrap import dedent

# ─────────────────────────────────────────────────────────
# Secrets / Config
# ─────────────────────────────────────────────────────────
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN", "")
GITHUB_REPO = os.getenv("GITHUB_REPO", "")             # e.g. "swanepoelchristo/milkbox-ai"
GITHUB_BRANCH = os.getenv("GITHUB_BRANCH", "main")

API_ROOT = "https://api.github.com"
HDRS = {
    "Authorization": f"token {GITHUB_TOKEN}",
    "Accept": "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
}

# ─────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────
def b64(s: str) -> str:
    return base64.b64encode(s.encode("utf-8")).decode("utf-8")

def slugify(s: str) -> str:
    s = s.strip().lower().replace(" ", "_").replace("-", "_")
    return "".join(ch for ch in s if (ch.isalnum() or ch == "_")).strip("_")

def gh_get(path: str, params=None):
    return requests.get(f"{API_ROOT}{path}", headers=HDRS, params=params or {})

def gh_post(path: str, payload: dict):
    return requests.post(f"{API_ROOT}{path}", headers=HDRS, json=payload)

def gh_put(path: str, payload: dict):
    return requests.put(f"{API_ROOT}{path}", headers=HDRS, json=payload)

def gh_content_get(path: str, ref: str = None):
    params = {"ref": ref} if ref else None
    return gh_get(f"/repos/{GITHUB_REPO}/contents/{path}", params=params)

def gh_content_put(path: str, message: str, content_b64: str, branch: str, sha: str | None = None):
    payload = {"message": message, "content": content_b64, "branch": branch}
    if sha:
        payload["sha"] = sha
    return gh_put(f"/repos/{GITHUB_REPO}/contents/{path}", payload)

def open_issue(title: str, body: str):
    return gh_post(f"/repos/{GITHUB_REPO}/issues", {"title": title, "body": body})

def open_pr(title: str, head_branch: str, base_branch: str = GITHUB_BRANCH, body: str = ""):
    return gh_post(f"/repos/{GITHUB_REPO}/pulls", {
        "title": title,
        "head": head_branch,
        "base": base_branch,
        "body": body
    })

def fetch_yaml_from_main(path="tools.yaml"):
    r = gh_content_get(path, ref=GITHUB_BRANCH)
    if r.status_code != 200:
        return None, None, f"Could not read {path}: {r.status_code}"
    data = r.json()
    content = base64.b64decode(data["content"]).decode("utf-8")
    sha = data["sha"]
    try:
        y = yaml.safe_load(content) or {}
    except Exception as e:
        return None, None, f"YAML parse error: {e}"
    return y, sha, None

def ensure_tools_entry(ydata: dict, key: str, label: str):
    ydata = ydata or {}
    tools = ydata.get("tools", [])
    if not any(isinstance(t, dict) and t.get("key") == key for t in tools):
        tools.append({"key": key, "label": label, "module": f"tools.{key}"})
    ydata["tools"] = tools
    return ydata

def generate_tool_py(key: str, label: str, description: str) -> str:
    # Avoid f-string here to dodge nested quote issues
    desc = (description or "New tool created by the Tool Builder.").replace('"', '\\"')
    code = dedent(
        """
        import streamlit as st

        def render():
            st.header("🧩 {label}")
            st.write("{desc}")

            with st.form("{key}_form", clear_on_submit=False):
                example = st.text_input("Example input", value="")
                submitted = st.form_submit_button("Run")

            if submitted:
                st.success(f"✅ {label} ran! You typed: {{example}}")
        """
    ).strip()
    return code.format(label=label, desc=desc, key=key)

def format_issue_body(spec_path: str, brief: dict) -> str:
    nice = json.dumps(brief, indent=2)
    body = dedent(
        """
        ### Tool Spec

        Spec file: `{spec_path}`

        ```json
        {nice}
        ```
        """
    ).strip()
    return body.format(spec_path=spec_path, nice=nice)

def format_pr_body(key: str, label: str, spec_path: str) -> str:
    body = dedent(
        """
        This PR introduces the **{label}** tool.

        - Tool key: `{key}`
        - Spec: `{spec_path}`
        - Auto-generated by the in-app Tool Builder.

        Please review the generated scaffold and extend the implementation.
        """
    ).strip()
    return body.format(key=key, label=label, spec_path=spec_path)

# ─────────────────────────────────────────────────────────
# UI
# ─────────────────────────────────────────────────────────
def render():
    st.header("🛠️ Tool Builder")
    st.caption("This tool takes a name + description and creates a scaffold tool in GitHub, then registers it in tools.yaml.")

    # Inputs
    with st.form("tool_builder_form", clear_on_submit=False):
        key_raw = st.text_input("Tool key (e.g. invoice_gen)")
        label = st.text_input("Tool label (e.g. Invoice Generator)")
        desc = st.text_area("Short description (what this tool should do)")

        # Optional: later you can add 13-question spec; for now keep minimal
        submitted = st.form_submit_button("Generate tool")

    if not submitted:
        return

    # Basic validation
    key = slugify(key_raw)
    if not key:
        st.error("Please provide a valid tool key.")
        return
    if not label:
        st.error("Please provide a tool label.")
        return

    # Check secrets present
    if not GITHUB_TOKEN or not GITHUB_REPO:
        st.error("Missing GitHub secrets. Set GITHUB_TOKEN (with repo scope) and GITHUB_REPO in Streamlit Cloud → Settings → Secrets.")
        return

    # Build file paths
    tool_py_path = f"streamlit_app/tools/{key}.py"
    spec_path = f"tool_specs/{key}.json"
    tools_yaml_path = "tools.yaml"

    # 1) Create/Update tool_specs/<key>.json
    spec_obj = {
        "key": key,
        "label": label,
        "description": desc,
        "created_at": datetime.utcnow().isoformat() + "Z",
        "status": "draft"
    }
    spec_json = json.dumps(spec_obj, indent=2)
    r = gh_content_get(spec_path, ref=GITHUB_BRANCH)
    spec_sha = r.json()["sha"] if r.status_code == 200 else None
    rsp = gh_content_put(
        spec_path,
        message=f"feat(tool-spec): add {key}.json",
        content_b64=b64(spec_json),
        branch=GITHUB_BRANCH,
        sha=spec_sha
    )
    if rsp.status_code not in (200, 201):
        st.error(f"GitHub error writing spec: {rsp.status_code} {rsp.text}")
        return
    st.success(f"📄 Wrote {spec_path}")

    # 2) Create streamlit_app/tools/<key>.py
    tool_py = generate_tool_py(key, label, desc)
    r = gh_content_get(tool_py_path, ref=GITHUB_BRANCH)
    tool_sha = r.json()["sha"] if r.status_code == 200 else None
    rsp = gh_content_put(
        tool_py_path,
        message=f"feat(tool): scaffold {key}.py",
        content_b64=b64(tool_py),
        branch=GITHUB_BRANCH,
        sha=tool_sha
    )
    if rsp.status_code not in (200, 201):
        st.error(f"GitHub error writing tool code: {rsp.status_code} {rsp.text}")
        return
    st.success(f"🧩 Created {tool_py_path}")

    # 3) Update tools.yaml (add entry if missing)
    ydata, ysha, yerr = fetch_yaml_from_main(tools_yaml_path)
    if yerr:
        st.error(yerr)
        return
    ydata = ensure_tools_entry(ydata, key, label)
    updated_yaml = yaml.safe_dump(ydata, sort_keys=False)
    rsp = gh_content_put(
        tools_yaml_path,
        message=f"chore(tools): register {key} in tools.yaml",
        content_b64=b64(updated_yaml),
        branch=GITHUB_BRANCH,
        sha=ysha
    )
    if rsp.status_code not in (200, 201):
        st.error(f"GitHub error updating tools.yaml: {rsp.status_code} {rsp.text}")
        return
    st.success("🗂️ Registered the tool in tools.yaml. It should appear in the sidebar now.")

    # 4) Open an Issue (reference the spec)
    issue_title = f"[Tool Spec] {label} ({key})"
    issue_body = format_issue_body(spec_path, spec_obj)
    ir = open_issue(issue_title, issue_body)
    if ir.status_code in (200, 201):
        st.info("📌 Opened an Issue for this tool’s spec.")
    else:
        st.warning(f"Could not open Issue: {ir.status_code} {ir.text}")

    # 5) (Optional) Open a PR from the same branch if you prefer a PR workflow
    # Skipped here because we are writing directly to main. You can switch to branch+PR later.

# Expose to the app loader
def main():
    render()
